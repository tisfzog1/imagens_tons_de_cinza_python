# -*- coding: utf-8 -*-
"""Imagens tons de cinza python

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUMgKg9kIGBFzfw22QVWmdZew_FDLkXs
"""

import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
import matplotlib.image as mpimg

# --- Parte para Carregar Sua Imagem ---
print("Por favor, selecione a imagem que você quer usar:")
uploaded = files.upload()

# O 'uploaded' será um dicionário onde as chaves são os nomes dos arquivos
# e os valores são os conteúdos dos arquivos em bytes.
# Vamos pegar o nome do primeiro arquivo enviado.
nome_arquivo_imagem = list(uploaded.keys())[0]

# Ler a imagem usando matplotlib
# mpimg.imread retorna um array numpy diretamente
imagem_colorida_sua = mpimg.imread(nome_arquivo_imagem)

# mpimg.imread pode retornar valores float entre 0 e 1 para imagens com canal alfa ou em certos formatos.
# Para garantir compatibilidade com nossas funções que esperam uint8 (0-255), vamos converter:
# Se a imagem for float (0.0 a 1.0), multiplicamos por 255 e convertemos para uint8.
# Se já for uint8, essa conversão não fará mal.
if imagem_colorida_sua.dtype != np.uint8:
    # Verifica se a imagem tem 3 ou 4 canais (RGB ou RGBA)
    if imagem_colorida_sua.ndim == 3 and imagem_colorida_sua.shape[2] in [3, 4]:
        # Se tiver 4 canais (RGBA), pegamos apenas os 3 primeiros (RGB)
        if imagem_colorida_sua.shape[2] == 4:
            imagem_colorida_sua = imagem_colorida_sua[:, :, :3]
        # Converte de float [0, 1] para uint8 [0, 255]
        imagem_colorida_sua = (imagem_colorida_sua * 255).astype(np.uint8)
    else:
        raise TypeError("Formato de imagem inesperado. Esperava RGB ou RGBA.")

print(f"\nImagem '{nome_arquivo_imagem}' carregada com sucesso!")
print(f"Formato da imagem carregada: {imagem_colorida_sua.shape}")
print(f"Tipo de dado da imagem carregada: {imagem_colorida_sua.dtype}")

# --- Funções de Binarização (as mesmas de antes) ---

def converter_para_tons_de_cinza(imagem_colorida):
    """
    Converte uma imagem colorida (RGB) em tons de cinza.
    Utiliza a fórmula de luminância: Cinza = 0.299*R + 0.587*G + 0.114*B

    Args:
        imagem_colorida (np.ndarray): Array NumPy 3D representando a imagem colorida (altura, largura, 3).

    Returns:
        np.ndarray: Array NumPy 2D representando a imagem em tons de cinza (altura, largura).
    """
    if imagem_colorida.ndim != 3 or imagem_colorida.shape[2] != 3:
        raise ValueError("A imagem de entrada deve ser colorida (com 3 canais RGB).")

    r_coef = 0.299
    g_coef = 0.587
    b_coef = 0.114

    imagem_cinza = np.dot(imagem_colorida[..., :3], [r_coef, g_coef, b_coef])
    imagem_cinza = np.clip(imagem_cinza, 0, 255).astype(np.uint8)

    return imagem_cinza

def binarizar_imagem_binaria(imagem_cinza, limiar=127):
    """
    Converte uma imagem em tons de cinza para uma imagem binária (preto e branco).

    Args:
        imagem_cinza (np.ndarray): Array NumPy 2D representando a imagem em tons de cinza.
        limiar (int): O valor de limiar para a binarização (0-255). Pixels com valor
                      menor ou igual ao limiar se tornam pretos (0), e os maiores
                      se tornam brancos (255).

    Returns:
        np.ndarray: Array NumPy 2D representando a imagem binária.
    """
    if imagem_cinza.ndim != 2:
        raise ValueError("A imagem de entrada deve estar em tons de cinza (2D).")

    imagem_binaria = np.zeros_like(imagem_cinza, dtype=np.uint8)
    imagem_binaria[imagem_cinza <= limiar] = 0  # Preto
    imagem_binaria[imagem_cinza > limiar] = 255 # Branco

    return imagem_binaria

# --- Processamento e Visualização ---

# 1. Converter a imagem carregada para tons de cinza
imagem_cinza_sua = converter_para_tons_de_cinza(imagem_colorida_sua)

# 2. Binarizar a imagem em tons de cinza (você pode mudar o limiar se quiser)
limiar_escolhido = 127 # Exemplo de limiar, pode ajustar
imagem_binaria_sua = binarizar_imagem_binaria(imagem_cinza_sua, limiar=limiar_escolhido)

# 3. Exibir as imagens usando matplotlib
plt.figure(figsize=(15, 5)) # Ajusta o tamanho da figura para acomodar as 3 imagens

# Imagem Original Colorida
plt.subplot(1, 3, 1) # 1 linha, 3 colunas, posição 1
plt.imshow(cv2.cvtColor(imagem_colorida_sua, cv2.COLOR_BGR2RGB)) # Correção de cor para exibição
plt.title("Imagem Original Colorida")
plt.axis('off') # Remove os eixos

# Commented out IPython magic to ensure Python compatibility.
# Install OpenCV
# %pip install opencv-python

import cv2

# Imagem Original Colorida
plt.subplot(1, 3, 1) # 1 linha, 3 colunas, posição 1
plt.imshow(imagem_colorida_sua) # Removed cv2.cvtColor as it's not needed
plt.title("Imagem Original Colorida")
plt.axis('off') # Remove os eixos
# Imagem em Tons de Cinza
plt.subplot(1, 3, 2) # 1 linha, 3 colunas, posição 2
plt.imshow(imagem_cinza_sua, cmap='gray') # Usamos 'gray' para exibir imagens em tons de cinza
plt.title("Imagem em Tons de Cinza")
plt.axis('off')

# Imagem Binária
plt.subplot(1, 3, 3) # 1 linha, 3 colunas, posição 3
plt.imshow(imagem_binaria_sua, cmap='gray') # Imagens binárias também usam 'gray'
plt.title("Imagem Binária")
plt.axis('off')

plt.tight_layout() # Ajusta o layout para evitar sobreposição de títulos
plt.show() # Exibe a figura com todas as subplots

